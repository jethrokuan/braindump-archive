<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-11-26 Mon 09:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coding Interview Preparation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Jethro Kuan" />
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Coding Interview Preparation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf55bbc1">1. Data Structures Review</a>
<ul>
<li><a href="#orgad9286d">1.1. <span class="todo TODO">TODO</span> How Primitive Types are represented in</a></li>
<li><a href="#org0665e32">1.2. Primitive Types</a>
<ul>
<li>
<ul>
<li><a href="#orgd7149bf">1.2.0.1. Bit Manipulation</a></li>
<li><a href="#org087b15c">1.2.0.2. Swapping Bits</a></li>
<li><a href="#org4a6f900">1.2.0.3. Cheatsheet</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc618635">1.3. Arrays</a></li>
<li><a href="#orgbe56195">1.4. Linked List</a></li>
<li><a href="#orgeddda17">1.5. Queues</a>
<ul>
<li><a href="#orgcfff571">1.5.1. Queues with Circular Buffer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga4cfd4c">2. Common Questions</a>
<ul>
<li><a href="#orgdac21e4">2.1. Find kth largest in array</a></li>
<li><a href="#org6aee18f">2.2. Boyer-Moore String Search Algorithm</a></li>
<li><a href="#org8ec8e5a">2.3. Delete Duplicates in Linked List</a></li>
<li><a href="#org37135b6">2.4. Longest Increasing Subsequence (LIS)</a></li>
<li><a href="#orga4a43b0">2.5. Generating a Random Sample</a></li>
<li><a href="#orgeaa577c">2.6. Generate a random sample from a stream</a></li>
<li><a href="#orga7bcc25">2.7. Checking sub-sequence</a></li>
<li><a href="#org39b64d8">2.8. Flatten a List</a></li>
<li><a href="#org96814d5">2.9. has two sum</a></li>
<li><a href="#orgcc21189">2.10. Big Integer Multiply</a></li>
<li><a href="#org27c8f85">2.11. Next Permutation</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgf55bbc1" class="outline-2">
<h2 id="orgf55bbc1"><span class="section-number-2">1</span> Data Structures Review</h2>
<div class="outline-text-2" id="text-1">
<p>
Integers in Python
</p>
</div>
<div id="outline-container-orgad9286d" class="outline-3">
<h3 id="orgad9286d"><span class="section-number-3">1.1</span> <span class="todo TODO">TODO</span> How Primitive Types are represented in</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>Python</li>
<li>C++</li>
</ol>
</div>
</div>

<div id="outline-container-org0665e32" class="outline-3">
<h3 id="org0665e32"><span class="section-number-3">1.2</span> Primitive Types</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Integers in Python 3 are unbounded &#x2013; the maximum integer
representable is a function of available memory. The constant
<code>sys.maxsize</code> can be used to find the word-size. Bounds on floats are
specified in <code>sys.float_info</code>.
</p>
</div>

<div id="outline-container-orgd7149bf" class="outline-5">
<h5 id="orgd7149bf"><span class="section-number-5">1.2.0.1</span> Bit Manipulation</h5>
<div class="outline-text-5" id="text-1-2-0-1">
<p>
Computing the parity of a word.
</p>
<div class="org-src-container">
<pre class="src src-python">def parity(x):
    result = 0
    while x:
        result ^= x &amp; 1
        x &gt;&gt;= 1
    return result
</pre>
</div>

<p>
<code>x &amp;</code> x - 1= Drops the lowest set bit of x. 
</p>

<p>
The parity of 11011111 is the same as the parity of 1101 XORed with 1111.
</p>
<div class="org-src-container">
<pre class="src src-python">def parity(x):
    x ^= x &gt;&gt; 32
    x ^= x &gt;&gt; 16
    x ^= x &gt;&gt; 8
    x ^= x &gt;&gt; 4
    x ^= x &gt;&gt; 2
    x ^= x &gt;&gt; 1
    return x &amp; 0x1
</pre>
</div>

<p>
With time complexity of \(O(\log n)\).
</p>
</div>
</div>

<div id="outline-container-org087b15c" class="outline-5">
<h5 id="org087b15c"><span class="section-number-5">1.2.0.2</span> Swapping Bits</h5>
<div class="outline-text-5" id="text-1-2-0-2">
<div class="org-src-container">
<pre class="src src-python">def swap_bits(x, i, j):
    if (x &gt;&gt; i) &amp; 1 != (x &gt;&gt; j) &amp; 1: # if ith and jth bits differ
        bit_mask = (1 &lt;&lt; i) | (1 &lt;&lt; j)
        x ^= bit_mask
    return x

</pre>
</div>
</div>
</div>
<div id="outline-container-org4a6f900" class="outline-5">
<h5 id="org4a6f900"><span class="section-number-5">1.2.0.3</span> Cheatsheet</h5>
<div class="outline-text-5" id="text-1-2-0-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">expression</th>
<th scope="col" class="org-left">output</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x &amp; x - 1</td>
<td class="org-left">clears the lowest set bit of x</td>
</tr>

<tr>
<td class="org-left">x &amp; ~(x-1)</td>
<td class="org-left">extracts the lowest set bit of x</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgc618635" class="outline-3">
<h3 id="orgc618635"><span class="section-number-3">1.3</span> Arrays</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Arrays are contiguous blocks of memory, usually used to represent
sequences.
</p>

<p>
Insertion into a full array can be handled by resizing, allocating a
new array with additional memory and copying over the entries from the
original array.
</p>
</div>
</div>

<div id="outline-container-orgbe56195" class="outline-3">
<h3 id="orgbe56195"><span class="section-number-3">1.4</span> Linked List</h3>
<div class="outline-text-3" id="text-1-4">
<div class="org-src-container">
<pre class="src src-python">class ListNode(object):
    def __init__(self, data=0, next_node=None):
        self.data = data
        self.next = next_node
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def search_list(L, key):
    while L and L.data != key:
        L = L.next
    return L
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def insert_after(node, new_node):
    new_node.next = node.next
    node.next = new_node
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def delete_after(node):
    # Need to make sure there is something after to delete
    if node.next:
        node.next = node.next.next
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeddda17" class="outline-3">
<h3 id="orgeddda17"><span class="section-number-3">1.5</span> Queues</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgcfff571" class="outline-4">
<h4 id="orgcfff571"><span class="section-number-4">1.5.1</span> Queues with Circular Buffer</h4>
<div class="outline-text-4" id="text-1-5-1">
<div class="org-src-container">
<pre class="src src-python">class Queue:
    SCALING_FACTOR = 2

    def __init__(self, capacity):
        self._entries = [None] * capacity
        self._head = self._tail = self._num_queue_elements = 0

    def enqueue(self, x):
        if self._num_queue_elements == len(self._entries):
            # Need to resize
            self._entries = (
                self._entries[self._head:] + self._entries[:self._head])
            self._head, self._tail = 0, self._num_queue_elements
            self._entries += [None] * (len(self._entries) * Queue.SCALING_FACTOR)

        self._entries[self._tail] = x
        self._tail = (self._tail + 1) % self._num_queue_elements
        self._num_queue_elements += 1

    def dequeue(self, x):
        if not self._num_queue_elements:
            raise IndexError("Empty queue")

        self._num_queue_elements -= 1
        ret = self._entries[self._head]
        self._head = (self._head + 1) % len(self._entries)
        return ert

    @property
    def size(self):
        return self._num_queue_elements
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orga4cfd4c" class="outline-2">
<h2 id="orga4cfd4c"><span class="section-number-2">2</span> Common Questions</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgdac21e4" class="outline-3">
<h3 id="orgdac21e4"><span class="section-number-3">2.1</span> Find kth largest in array</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">
<pre class="src src-python">import operator

# The numbering starts from one, i.e., if A = [3, 1, -1, 2]
# find_kth_largest(1, A) returns 3, find_kth_largest(2, A) returns 2,
# find_kth_largest(3, A) returns 1, and find_kth_largest(4, A) returns -1.
def find_kth_largest(k, A):
    def find_kth(comp):
        # Partition A[left:right + 1] around pivot_idx, returns the new index of
        # the pivot, new_pivot_idx, after partition. After partitioning,
        # A[left:new_pivot_idx] contains elements that are "greater than" the
        # pivot, and A[new_pivot_idx + 1:right + 1] contains elements that are
        # "less than" the pivot.
        #
        # Note: "greater than" and "less than" are defined by the comp object.
        #
        # Returns the new index of the pivot element after partition.
        def partition_around_pivot(left, right, pivot_idx):
            pivot_value = A[pivot_idx]
            new_pivot_idx = left
            A[pivot_idx], A[right] = A[right], A[pivot_idx]
            for i in range(left, right):
                if comp(A[i], pivot_value):
                    A[i], A[new_pivot_idx] = A[new_pivot_idx], A[i]
                    new_pivot_idx += 1
            A[right], A[new_pivot_idx] = A[new_pivot_idx], A[right]
            return new_pivot_idx

        left, right = 0, len(A) - 1
        while left &lt;= right:
            # Generates a random integer in [left, right].
            pivot_idx = random.randint(left, right)
            new_pivot_idx = partition_around_pivot(left, right, pivot_idx)
            if new_pivot_idx == k - 1:
                return A[new_pivot_idx]
            elif new_pivot_idx &gt; k - 1:
                right = new_pivot_idx - 1
            else:  # new_pivot_idx &lt; k - 1.
                left = new_pivot_idx + 1

        raise IndexError('no k-th node in array A')

    return find_kth(operator.gt)
</pre>
</div>
</div>
</div>

<div id="outline-container-org6aee18f" class="outline-3">
<h3 id="org6aee18f"><span class="section-number-3">2.2</span> Boyer-Moore String Search Algorithm</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The problem is to find a occurrences of string <code>p</code> in <code>t</code>. The pattern <code>p</code>
is preprocessed, learning from character comparisons to skip pointless
alignments.
</p>

<ol class="org-ol">
<li>Try alignments in left-to-right order</li>
<li>Try character comparisons in right-to-left order</li>
</ol>

<p>
<b>Bad character rule</b>: Upon mismatch, skip alignments until (a) mismatch
becomes a match (b) <code>p</code> moves past mismatched character
</p>

<div class="org-src-container">
<pre class="src src-text">T: GCTTCTGCTATCTCTC
P: CCTTTTGC
       ^ mismatch (right-to-left character comparison)
    ^ earliest C to make mismatch match
       CCTTTTGC
</pre>
</div>

<p>
<b>Good suffix rule</b>: Let <code>t</code> = matched by inner loop; skip until (a) there
are no mismatches between <code>p</code> and <code>t</code>, or (b) <code>p</code> moves past <code>t</code>
</p>

<p>
Another linear-time string search algorithm is the <a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm">Rabin-Karp
algorithm</a>, which uses a rolling hash.
</p>
</div>
</div>

<div id="outline-container-org8ec8e5a" class="outline-3">
<h3 id="org8ec8e5a"><span class="section-number-3">2.3</span> Delete Duplicates in Linked List</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">
<pre class="src src-python">def deleteDuplicates(A):
    head = A
    while A:
        while A.next and A.next.val == A.val:
            A.next = A.next.next
        A = A.next
    return head
</pre>
</div>
</div>
</div>

<div id="outline-container-org37135b6" class="outline-3">
<h3 id="org37135b6"><span class="section-number-3">2.4</span> Longest Increasing Subsequence (LIS)</h3>
<div class="outline-text-3" id="text-2-4">
<p>
\(O(n^2)\) solution involves dynamic programming. Let \(L[i]\) be the
length of the LIS ending at index \(i\), such that \(arr[i]\) is the last
element of the LIS.
</p>

<p>
Then \(L(i) = 1 + max(L[j])\) where \(0 < j < i\) and \(arr[j] < arr[i]\) or
\(L[i] = 1\) if no such \(j\) exists.
</p>

<div class="org-src-container">
<pre class="src src-python">def longest_increasing_subsequence(arr):
    l = len(arr)
    # Initialize LIS
    lis = [1] * l

    for i in range(1, l):
        for j in range(0, i):
            if arr[i] &gt; arr[j]:
                lis[i] = max(lis[i], lis[j] + 1)

    return max(lis)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4a43b0" class="outline-3">
<h3 id="orga4a43b0"><span class="section-number-3">2.5</span> Generating a Random Sample</h3>
<div class="outline-text-3" id="text-2-5">
<div class="org-src-container">
<pre class="src src-python">import random

def random_sample(k, A):
    """Generates a rondom subset of size k from array A."""
    for i in range(k):
        r = random.randint(i, len(A)-1)
        A[i], A[r] = A[r], A[i]
    return A[:k]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeaa577c" class="outline-3">
<h3 id="orgeaa577c"><span class="section-number-3">2.6</span> Generate a random sample from a stream</h3>
<div class="outline-text-3" id="text-2-6">
<p>
The basic idea is that given the <code>n+1</code> element, and a random subset of
size <code>k</code>, where <code>k&lt;n</code>, then that element should belong to that new subset
with probability <code>k/(n+1)</code>.
</p>

<div class="org-src-container">
<pre class="src src-python">import random

def online_random_sample(it, A):
    # Stores the first k elements
    sampling_results = list(itertools.islice(it, k))

    num_seen_so_far = k
    for x in it:
        num_seen_so_far += 1
        idx_to_replace = random.randrange(num_seen_so_far)
        if idx_to_replace &lt; k:
            sampling_results[idx_to_replace] = x

    return sampling_results
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7bcc25" class="outline-3">
<h3 id="orga7bcc25"><span class="section-number-3">2.7</span> Checking sub-sequence</h3>
<div class="outline-text-3" id="text-2-7">
<div class="org-src-container">
<pre class="src src-python">def is_subsequence(st, seq):
    it = iter(st)
    return all(c in it for c in seq)

print(is_subsequence("hello", "el"))
print(is_subsequence("hello", "no"))
</pre>
</div>
</div>
</div>
<div id="outline-container-org39b64d8" class="outline-3">
<h3 id="org39b64d8"><span class="section-number-3">2.8</span> Flatten a List</h3>
<div class="outline-text-3" id="text-2-8">
<div class="org-src-container">
<pre class="src src-python">def flatten(arr):
    return [item for sublist in l for item in sublist]
</pre>
</div>
</div>
</div>
<div id="outline-container-org96814d5" class="outline-3">
<h3 id="org96814d5"><span class="section-number-3">2.9</span> has two sum</h3>
<div class="outline-text-3" id="text-2-9">
<div class="org-src-container">
<pre class="src src-python">def has_two_sum(A, t):
    i, j = 0, len(A) - 1

    while i &lt;= j:
        if A[i] + A[j] == t:
            return True
        elif A[i] + A[j] &lt; t:
            i += 1
        else:  # A[i] + A[j] &gt; t.
            j -= 1
    return False
</pre>
</div>

<p>
has three sum is the same, sort the array and run has two sum.
</p>
</div>
</div>
<div id="outline-container-orgcc21189" class="outline-3">
<h3 id="orgcc21189"><span class="section-number-3">2.10</span> Big Integer Multiply</h3>
<div class="outline-text-3" id="text-2-10">
<div class="org-src-container">
<pre class="src src-python">def multiply(num1, num2):
    sign = -1 if (num1[0] &lt; 0) ^ (num2[0] &lt; 0) else 1
    num1[0] = abs(num1[0])
    num2[0] = abs(num2[0])
    result = [0] * (len(num1) + len(num2))
    for i in reversed(range(len(num1))):
        for j in reversed(range(len(num2))):
            result[i + j + 1] += num1[i] * num2[j]
            result[i + j] += result[i + j + 1] // 10
            result[i + j + 1] %= 10

    # remove starting 0s
    result = result[next((
        i for i, x in enumerate(result) if x != 0), len(result)):] or [0]
    result[0] *= sign
    return result
</pre>
</div>
</div>
</div>
<div id="outline-container-org27c8f85" class="outline-3">
<h3 id="org27c8f85"><span class="section-number-3">2.11</span> Next Permutation</h3>
<div class="outline-text-3" id="text-2-11">
<div class="org-src-container">
<pre class="src src-python">def next_permutation(perm):

    # Find the first entry from the right that is smaller than the entry
    # immediately after it.
    inversion_point = len(perm) - 2
    while (inversion_point &gt;= 0
           and perm[inversion_point] &gt;= perm[inversion_point + 1]):
        inversion_point -= 1
    if inversion_point == -1:
        return []  # perm is the last permutation.

    # Swap the smallest entry after index inversion_point that is greater than
    # perm[inversion_point]. Since entries in perm are decreasing after
    # inversion_point, if we search in reverse order, the first entry that is
    # greater than perm[inversion_point] is the entry to swap with.
    for i in reversed(range(inversion_point + 1, len(perm))):
        if perm[i] &gt; perm[inversion_point]:
            perm[inversion_point], perm[i] = perm[i], perm[inversion_point]
            break

    # Entries in perm must appear in decreasing order after inversion_point,
    # so we simply reverse these entries to get the smallest dictionary order.
    perm[inversion_point + 1:] = reversed(perm[inversion_point + 1:])
    return perm
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jethro Kuan</p>
<p class="date">Created: 2018-11-26 Mon 09:54</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
